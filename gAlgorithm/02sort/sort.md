[TOC]
# 1. 排序算法
+ 算法稳定性

## 1.1 选择排序
1. "放在"的本质 是 swap操作
2. 每一轮遍历完成后; 最小值 在 待排序数值的最左边
### 算法步骤
1. 每次从待排序 数值中选取最小值; 
2. 放在待排序 数值的最前面
3. 对剩下的元素重复 1. ~ 2.
4. n个元素则重复n-1次; 直到排序完成

## 1.2 插入排序
1. 对待排序数值; 在以排序的数值中 从后往前扫描; 找到相应位置后插入
2. "插入"是形象化的描述; 实际上是在一个循环中把数值`a[i]` 不断从右往左移动
### 算法步骤
1. 假设 `a[0:i-1]` 已排序; 选取 `a[i]`
2. `a[i]` 从右往左与 `a[i-1]` ~ `a[0]` 比较
3. 如果 `a[i]` 数值相对较少; 则 `a[i]` 左移
4. 直到 `a[i]` 插入相应的位置(即 左方的数值比 `a[i]` 小)
5. 重复 1. ~ 4. n-1 次

## 1.3 冒泡排序
1. 冒泡排序法; 每次循环后是 最后边数值为最大
2. 即排序过程中; 待排序数值 从右边往左边 从大到小 逐渐完成排序
### 算法步骤
1. 从左往右依次比较相邻的元素; 把较大的元素右移 (即交换)
2. 单次循环 直到 最后一对相邻元素 `a[n-1-i-1]` 和 `a[n-1-i]` (i 为循环次数)
3. 重复 1. 2. `n-1` 次

## 1.4 快速排序
1. 快速排序不是稳定算法; 其效率取决于pivot的选取; 
2. 如果pivot总是在子数组端点; 则根本没有拆分; 复杂度为 `O(n**2)`
3. 快速排序的主题思想上是 分治+递归
4. 递归本质:
    1. 基线条件: `子数组长度 < 2` (实际上是两个条件: 数组为空 + 数组长度为1)
    2. 递归操作: 选取基准值; 拆分两数组
    2. 递归条件: (无条件) 分别对两个子数组进行排序
### 算法步骤
1. 选取基准值 pivot
2. 将数组分成两个子数组: 小于基准值的一组 和 大于基准值的一组 partition
3. 分别对两个子数组进行快速排序
4. 重复1. ~ 3.

## 1.5 归并排序 (迭代法 / 递归法)
1. 先 2个 2个地排序; 再 4个 4个地排序; 然后 8个 8个地排序; ...
### 算法步骤 (迭代法)
1. 申请空间; 尺度同于待排序数组
2. 设定两个指针; 最初位置位置分别指向两个已排序数组的起始位置
3. 比较两个指针指向的元素; 选择相对较少的元素放入合并空间
4. 重复步骤3; 直到两个指针任意一个丞相序列末尾
5. 将另一个序列的所有元素直接复制到合并序列的尾部

## 1.6 堆排序
## 1.7 希尔排序
## 1.8 基数排序
## 1.9 计数排序
## 1.10 桶排序

## 归并排序
运行时间总是`Ｏ(n*log2n)`

### 算法思想

# 2. 总结
## 2.1 算法比较
| 类型   | 排序算法       | 平均时间复杂度 | 最坏情况     | 最好情况     | 空间复杂度 | 稳定性 |
| :-:    | :-:            | :-:            | :-:          | :-:          | :-:        | :-:    |
| 内排序 | 选择排序(选择) | `O(n**2)`      | `O(n**2)`    | `O(n**2)`    | `O(1)`     | 不稳定 |
| 内排序 | 插入排序(插入) | `O(n**2)`      | `O(n**2)`    | `O(n)`       | `O(1)`     | 稳定   |
| 内排序 | 冒泡排序(交换) | `O(n**2)`      | `O(n**2)`    | `O(n)`       | `O(1)`     | 稳定   |
| 内排序 | 快速排序(交换) | `O(n*log2n)`   | `O(n**2)`    | `O(n*log2n)` | `O(log2n)` | 不稳定 |
| 内排序 | 归并排序       | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(n)`     | 稳定   |
| 内排序 |  堆排序 (选择) | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(1)`     | 不稳定 |
| 内排序 | 希尔排序(插入) | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(1)`     | 不稳定 |
| 外排序 | 基数排序       | `O(n * k)`     | `O(n * k)`   | `O(n * k)`   | `O(n + k)` | 稳定   |
| 外排序 | 计数排序       | `O(n + k)`     | `O(n * k)`   | `O(n + k)`   | `O(k)`     | 稳定   |
| 外排序 |  桶排序        | `O(n + k)`     | `O(n * k)`   | `O(n + k)`   | `O(n + k)` | 稳定   |
## 2.1 算法稳定性
1. 算法稳定性是指: 相同数值的元素; 经过排序后; 其相对顺序保持不变
   + 不是时间复杂度的稳定性
## 2.2 Q: 为什么说 快速排序 绝大多数情况下优于 归并排序
1. 因为平均复杂度 快速排序 同与 归并排序
2. 但是 快速排序的 `O(nlog2n)` 的常数因子 比起 归并排序要小得多