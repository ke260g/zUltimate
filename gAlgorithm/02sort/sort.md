[TOC]
# 1. 排序算法
## 1.1 选择排序
1. "放在"的本质 是 swap操作
2. 每一轮遍历完成后; 最小值 在 待排序数值的最左边
### 算法步骤
1. 每次从待排序 数值中选取最小值; 
2. 放在待排序 数值的最前面
3. 对剩下的元素重复 1. ~ 2.
4. n个元素则重复n-1次; 直到排序完成

## 1.2 插入排序
1. 对待排序数值; 在以排序的数值中 从后往前扫描; 找到相应位置后插入
2. "插入"是形象化的描述; 实际上是在一个循环中把数值`a[i]` 不断从右往左移动
### 算法步骤
1. 假设 `a[0:i-1]` 已排序; 选取 `a[i]`
2. `a[i]` 从右往左与 `a[i-1]` ~ `a[0]` 比较
3. 如果 `a[i]` 数值相对较少; 则 `a[i]` 左移
4. 直到 `a[i]` 插入相应的位置(即 左方的数值比 `a[i]` 小)
5. 重复 1. ~ 4. n-1 次

## 1.3 冒泡排序
1. 冒泡排序法; 每次循环后是 最后边数值为最大
2. 即排序过程中; 待排序数值 从右边往左边 从大到小 逐渐完成排序
### 算法步骤
1. 从左往右依次比较相邻的元素; 把较大的元素右移 (即交换)
2. 单次循环 直到 最后一对相邻元素 `a[n-1-i-1]` 和 `a[n-1-i]` (i 为循环次数)
3. 重复 1. 2. `n-1` 次

## 1.4 快速排序
1. 快速排序不是稳定算法; 其效率取决于pivot的选取; 
2. 如果pivot总是在子数组端点; 则根本没有拆分; 复杂度为 `O(n**2)`
3. 快速排序的主题思想上是 分治+递归
4. 递归本质:
    1. 基线条件: `子数组长度 < 2` (实际上是两个条件: 数组为空 + 数组长度为1)
    2. 递归操作: 选取基准值; 拆分两数组
    2. 递归条件: (无条件) 分别对两个子数组进行排序
### 算法步骤
1. 选取基准值 pivot
2. 将数组分成两个子数组: 小于基准值的一组 和 大于基准值的一组 partition
3. 分别对两个子数组进行快速排序
4. 重复1. ~ 3.

## 1.5 归并排序 (迭代法 / 递归法)
1. 先 2个 2个地排序; 再 4个 4个地排序; 然后 8个 8个地排序; ...
### 算法步骤 (迭代法)
1. 申请空间; 尺度同于待排序数组
2. 设定两个指针; 最初位置位置分别指向两个已排序数组的起始位置
3. 比较两个指针指向的元素; 选择相对较少的元素放入合并空间
4. 重复步骤3; 直到两个指针任意一个丞相序列末尾
5. 将另一个序列剩下的所有元素直接复制到合并序列的尾部

## 1.6 堆排序
### 算法步骤
1. 把整个数组构造大顶堆 (首个非叶节点开始到数据首元素 i--; 构造大顶堆)
2. 首元素与末元素交换
3. 交换后 数组尺寸减一 剩余数组重新构造大顶堆
4. 重复2 3 直到数组长度为空

+ 构造大顶堆步骤
    1. 从当前节点的左右子节点中; 找到 "较大子节点"
    2. 较大子节点 与 "当前节点" 交换
    3. 重新进行 1 2; 直到 "当前节点" 都大于子节点 or "当前节点" 变为叶节点

### 复杂度分析
1. 首次构建堆的复杂度为 O(n)
2. 需要 n - 1 次进行交换并重建
3. 每次重建的复杂度 `log2(n-1) log2(n-2) ...`； 近似为 log2n
4. 所以总的复杂度 = `O(n) + O(n*log2n) = O(n*log2n)`

## 1.7 希尔排序
### 算法步骤
1. 通过步进划分小组; 初始步进是 `a.size() / 2`；每次循环步进除以2
2. 遍历每个小组; 每个小组从末元素开始遍历;
3. 每个小组遍历中  使用插入法排序
4. 直到步进为0, 结束算法

## 1.8 基数排序
## 算法步骤
1. 获取数组a中的最大值
2. 求最大指数(即最大值的位数)。
3. 从指数1开始到最大指数，根据位数对数组a中的元素进行桶排序

## 1.9 计数排序
### 算法步骤
1. 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；
2. 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；
3. 变换额外空间, 计算每一个元素在排序后最后出现的索引
4. 从后边开始; 将待排序集合每一个元素移动到3步骤计算得出的正确位置上。

## 1.10 桶排序
### 算法步骤
1. 根据待排序集合中最大元素和最小元素的差值范围和映射规则，确定申请的桶个数；
2. 遍历待排序集合，将每一个元素移动到对应的桶中；
3. 对每一个桶中元素进行排序，并移动到已排序集合中。

# 2. 总结
## 2.1 算法比较
| 类型   | 排序算法       | 平均时间复杂度 | 最坏情况     | 最好情况     | 空间复杂度 | 稳定性 | 每次选出最终位置 | 复杂度与初始位置 |
| :-:    | :-:            | :-:            | :-:          | :-:          | :-:        | :-:    | :-:              | :-:              |
| 内排序 | 选择排序(选择) | `O(n**2)`      | `O(n**2)`    | `O(n**2)`    | `O(1)`     | 不稳定 | 能, 选出最小元素 | 无关, 必须遍历   |
| 内排序 | 插入排序(插入) | `O(n**2)`      | `O(n**2)`    | `O(n)`       | `O(1)`     | 稳定   | 否               | 有关, 能提前结束 |
| 内排序 | 冒泡排序(交换) | `O(n**2)`      | `O(n**2)`    | `O(n)`       | `O(1)`     | 稳定   | 能, 选出最大元素 | 有关, 能提前结束 |
| 内排序 | 快速排序(交换) | `O(n*log2n)`   | `O(n**2)`    | `O(n*log2n)` | `O(log2n)` | 不稳定 | 否               | 有关, 影响复杂度 |
| 内排序 | 归并排序       | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(n)`     | 稳定   | 否               | 无关，都要归并   |
| 内排序 |  堆排序 (选择) | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(1)`     | 不稳定 | 能, 选出最大元素 | 无关, 都是建堆   |
| 内排序 | 希尔排序(插入) | `O(n*log2n)`   | `O(n*log2n)` | `O(n*log2n)` | `O(1)`     | 不稳定 | 否               | 有关, 能提前结束 |
| 外排序 | 基数排序       | `O(n * k)`     | `O(n * k)`   | `O(n * k)`   | `O(n + k)` | 稳定   | -----            | 无关             |
| 外排序 | 计数排序       | `O(n + m)`     | `O(n + m)`   | `O(n + m)`   | `O(n + m)` | 稳定   | -----            | 无关             |
| 外排序 |  桶排序        | `O(n + m)`     | `O(n + m)`   | `O(n + m)`   | `O(m)`     | 稳定   | -----            | 无关             |

## 2.1 算法稳定性
1. 算法稳定性是指: 相同数值的元素; 经过排序后; 其相对顺序保持不变
   + 不是时间复杂度的稳定性