# 动态规划
## 适用范围
1. 约束条件下求最优解
2. 问题可以拆分为系 离散的子问题时
## 算法设计指导
1. 求解方式通常涉及 矩阵
2. 矩阵的值通常是 子问题的最优解
3. 每个维度 对应 每个约束条件的离散化
4. 还要有标记用以回溯

# 经典问题
## Q: 离散 背包问题 (要么拿 要么不拿)
由承重为X的背包; 有若干不同价值 不同质量的商品; 如何一次性获取最大价值的商品?
```txt
        承重1  承重2 承重3 承重4 ... 承重N  (i)
商品1:   价值   价值  价值 价值  ... 价值
商品2:
商品3:
...:
商品M:
(j)
```
### 算法思想
1. `cell[i][j]` 的本质是 表示在承重为 i 的情况下, 已知商品 0 ~ j 的最大价值

### 算法步骤
1. 遍历 二维矩阵
   `cell[i][j] = max(cell[i-1][j], 当前商品价值 + cell[i-1][j - 当前商品质量])`
2. 最终价值 cell[N][M]
3. 回溯, 在cell中记录 max时的方向
### 注意事项
1. 承重计算单位 必须能规整化; 从而可以被 **j - 当前商品质量** 索引
2. 背包问题的最终答案不会因为 商品遍历序列的改变而改变; 但是矩阵本身会
3. 该算法可能导致 背包没装满


## Q: 最长公共子序列 lcs
```txt
   f  o  s  h (i)
f
o
r
t
(j)
```
### 算法思想
1. 二维矩阵; X Y轴分别表示两个字符串
2. `cell[i][j]` 的本质是 `X[0:i]` 与 `Y[0:j]` 的最长子串
3. 回溯思路:
    1. 二维矩阵的节点上打上 方向标记 ( 左上 / 上边 / 左边 / 左或上 )
    2. 广度优先算法 回溯路径表(二维链表)
### 算法步骤
1. 遍历二维矩阵  (起始条件: 赋值 cell[0][0] = X[0] == Y[j] ? 1 : 0;)
   `cell[i][j] = X[i] == Y[j] ? cell[i-1][j-1] + 1 : max(cell[i-1][j], cell[i][j-1])`
2. 回塑: 构造多解树 (广度优先)
    1. 二维矩阵右边下角节点插入`回溯路径表`
    2. 遍历`回溯路径表`中的每个链表;  
    3. 如果链表头到达边界 当前index++ (终止条件; 即完成了一条路径)
    4. 把 ( 左上 ) 的cell节点 *头插法* 插入当前 链表
    5. 把 ( 左 / 上 ) 的 cell节点 *替换* 当前链表头
    6. 若 (左或上) 则拷贝当前链表, 分表把 `左`和 `上` 两个节点替换 当前链表头 和 拷贝链表头
    7. 拷贝链表 加入列 `回溯路径表`
    8. 重复2. ~ 7.直到队列为空
3. 根据回溯多解表; 构造多解的字符串 (根据节点位置 )