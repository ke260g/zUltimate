[TOC]
# 1. 查找算法
| 算法 | 算法复杂度      | 平均查找时间 | 平均查找长度ASL         |
| 顺序 | O(n)            | n/2          | (n+1) / 2               |
| 二分 | O(log2n)        | log2n        | (1*1 + 2*2 + 3*4 ...)/n |
| 分块 | O(log2m) + O(s) |              | 块间二分 + 块内顺序     |
| hash | O(1)            | 1            | 不是1; 要根据散列情况算 |
## 1.1 顺序查找
+ 顺序查找的平均查找时间是 n/2; 时间复杂度 O(n)
## 1.2 二分查找
```c++
while (i <= j) {              // 等于号 表示 左闭右闭区间; 两端点可达
    m = (i + j) / 2
    if (value == v[m])
        return m;
    else if (value < v[m])
        j = m - 1;
    else
        i = m + 1;
}
return -1;
```

1. 算法复杂度 O(log2n)
2. 最坏的查找次数:
    + log2n    (n > 1)
    + log2n+1  (n = 1) 必须比较一次; 所以公式上要求 +1
3. 查找不成功次数为 log2n + 1 
4. 对线性表进行二分查找; 要求线性表必须 **顺序存储** **元素有序** (两个条件缺一不可)
5. **静态表** 就是指数组；**动态表** 就是指链表

## 1.3 分块查找
+ 块间元素有序 块内元素无序
+ 块间二分查找 块内顺序查找

## 1.4 二叉查找树
查找长度 = O(log2n) ~ O(n)
查找复杂与树形有关; 单枝树的查找复杂度最大 O(n)

## 1.5 斐波那契查找?

## 1.6 布隆过滤器

# 2. 平均查找长度 ASL
(每个元素的查找长度 总和 ) / 元素个数
## 2.1 顺序查找
1. 第n个元素的查找长度为n
2. 每个元素都有概率被查找
3. asl = n的整数求和公式 / n = ( n(n+1) / 2 ) / n = (n + 1) / 2

## 2.2 二分查找
1. 查找长度为 n 的元素个数有 2**(n-1) 个
2. 即 `( 1*1 + 2*2 + 4*3 + 8*4 + ... ) / n` 个

## 2.3 分块查找 ( m 块数; s 块间元素个数 )
asl = 块间二分查找asl + 块内顺序查找asl

## 2.4 哈希查找
1. 提高哈希查找的措施
    1. 设计冲突少的 散列函数
    2. 处理冲突时  避免产生聚集(堆积)
    3. 增加装填(装载)因子 == 是没有用的

# 3. 各种各样的坑
## hash array list 比较
| 操作 | hash 平均效率 | hash 最坏效率 | list | array | 
| :-:  | :-:           | :-:           | :-:  | :-:   |
| 查找 | O(1)          | O(n)          | O(n) | O(1)  |
| 插入 | O(1)          | O(1)          | O(1) | O(n)  |
| 删除 | O(1)          | O(n)          | O(1) | O(n)  |

# 经典问题
## Q: 字符串匹配
```txt
string:   G T T A T A G C T G G T A G C G G C G A A
pathern:  G T G T G C F
```
问题的本质就是 尽可能快地 右移pathern
    减少 mistmatch 后stringd的回溯
### BF 暴力求解
1. 把 string 的字符逐个作为 子字符串的头 与 pathern遍历
2. 每当出现 mismatch; string 的子字符串的头 + 1
    + 即每次 mismatch 只把 pathern 右移1位
### BM
### KMP
+ 这个算法的学习思路比较特殊
    1. 先理解 PMT; next数组的含义, 即值是怎么来
    2. 再理解如何使用 PMT 加快处pathern右移
    3. 最后采用 dp 求解 PMT
```txt
next数组:
char   :  a  b  a  b  a  b  c  a
index  :  0  1  2  3  4  5  6  7
pmt    :  0  0  1  2  3  4  0  1
next1  :  -1 0  0  1  2  3  4  0
next2  :  0  0  0  1  2  3  4  0 /* 优化1 */
nextval:                         /* 优化2 */

index  value的计算
  2    "aba"  前缀集合 { "a" "ab" },       后缀集合 { "ba", "a" };      因而值为 1
  3    "abab" 前缀集合 { "a" "ab" "aba" }, 后缀集合 { "bab" "ab" "b" }; 因而值为 2
```

1. PMT 部分匹配表: 前缀集合 和 后缀集合 的交集中最长元素的长度
   即 string 中 `0 ~ (PMT[i]-1)` 或者 `[0, PMT[i] )` 为最长元素
2. next数组: 为了编程方便, 把 PMT 数组右边移一个元素;
3. mismatch后: 字符串索引i 不变; 模式串索引j 左移(实际上是把 模式串右移)
   即对齐; 加快 模式串的右移
4. 优化1: 把`next[0] = 0`, 避免 模式串索引j 为 -1 的无效遍历
5. 优化2 nextval数组: 对于pathern 中的连续字符; 其 `next[i]` 可以是 `next[next[i-1]]`
    `nextval[i] = (s[i] == s[next[i-1]+1]) ? next[next[i - 1]] : next[i-1];`

## Q: 单词查找
1. 大量单词的查找 
### Trie 树 (hash 变种)
