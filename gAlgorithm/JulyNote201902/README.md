# July 团队的十大算法精讲 2015

时间复杂度 空间复杂度
多以优化时间复杂度为目标
空间换时间

+ 问题 + 思路 + 耗时分析 + 代码实现
+ WordNet 认知语言学的词典

hash: sdbm djb2 murmurhash
base64 md5 sha256 sha512 rsa

二叉搜索树 > 二叉树 > 平衡二叉树 > 红黑树 AVL树
+ 穷举法 动态规划 DFS BFS 贪心算法 (这几个算是某种模式)

# Binary Tree
+ 求树的高度
+ 随机一棵树: 随机一个数组 把数组构造为二叉树(平衡的 / 不平衡的)
+ 层状/深度/广度 遍历 (图论中使用)
+ 前序/中序/后序 遍历; 前驱/后续
+ 平衡二叉树: AVL RedBlack

### 前序/中序/后序 遍历
+ reorder/inorder/postorder
+ 递归方法 / 非递归方法
+ 前: 访问自己 递归左子树 递归右子树
    + 数组头 即根节点
+ 中: 递归左子树 访问自己 递归右子树 (即 二叉搜索树的升序)
+ 后: 递归左子树 递归右子树 访问自己 (压栈 高度最大)
    + 数组尾 即根节点
+ Q: 已知 前序/中序 求后序
+ Q: 已知 后序/中序 求前序
+ Note: 已知 前序/后序 树是不唯一的

### 不平衡二叉树4种范式(左右子树高度差为2) 及 AVL旋转
+ 左左: 单旋转 左旋 [使得left节点替代curr节点  维持树结构]
    1. tmp = g.left
    2. g.left = tmp.right
    3. tmp.right = g
    4. g = tmp
+ 左右: 双旋转
    1. 右旋 curr.left => 变成**左左**
    2. 左旋 curr
+ 右右: 单旋转 右旋 [使得right节点替代curr节点 维持树结构]
    1. tmp = g.right
    2. g.right = tmp.left
    3. tmp.left = g
    4. g = tmp
+ 右左: 双旋转
    1. 左旋 curr.right => 变成**右右**
    2. 右旋 curr

### 平衡二叉树 AVL树
+ 左右子树高度差 不大于1
+ add/del/get 的时间复杂度 T(n) = O(log2n)
+ add/del 的递归 **回退过程**, 需要log2n次的平衡(旋转)操作
+ 旋转操作发生在add/del后 即**回退过程**
+ 每次插入后 左右子树高度差 向上不断旋转
    + 插入完成后 从插入节点开始 维护一个到根节点的路径
    + 路径中每经过一个节点都要维持树的平衡
    + Note: 实际上 路径就是 递归查找的时候压入栈的节点
+ 删除
    + 若删除节点 在 当前节点的子树 => 看情况4种旋转
    + 若删除节点 为 当前节点且有两个子树: 前驱/后继法 + 删除后旋转
    + 若删除节点 为 当前节点且为单支: 直接替换 无需旋转

### RedBlack 树

## Binary Search Tree
+ 增/删/查 删有三种情况
+ 查
+ 增:
    1. 若当前节点为空 则插入元素为根
    2. 插入元素小于节点值 则递归进左子树
    3. 插入元素大于节点值 则递归进右子树
+ 删-待删点有左右子树: (方法1: 后继法)
    1. 后继的值 替换自己
    2. 删后继节点
    3. 后继的右节点 作为 后继父节点的左节点
+ 删-待删点有左右子树: (方法2: 前驱法)
    1. 前驱的值 替换自己
    2. 删前驱节点
    3. 前驱的左节点 作为 前驱父节点的右节点
+ 删-待删点为叶 直接删除
+ 删-待删点为单支

## B树
+ 变种: B+树 B-树 B*树
+ 应用: 磁盘
+ m阶B树需要满足的条件:
    1. 每个节点至多有m个孩子
    2. 除根节点外其他节点至多有 m/2个孩子
    3. 根节点至少有2个孩子
    4. 所有叶节点在同一层 (保证平衡)
    5. 有a个孩子的非叶节点有a-1个关键字
    6. 节点内关键字递增排列