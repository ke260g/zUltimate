[TOC]
https://www.cnblogs.com/xiaolincoding/p/12732052.html

# 1. 重传机制
1. 超时重传 和 快速重传 是默认自带的
2. sack 和 dsack 是快速重传基础上扩展出来的, 需要调参

## 1.1 超时重传 ( seq 丢失 / ack 丢失 )
1. seq 丢失: send 方发送的报文在网络中丢失, recv 方没有收到
    1. 发送方等待 ack 超时, 重发
2. ack 丢失: recv 方确实收到报文, 然后发送 ack, 但丢失了
    1. 发送方等待 ack 超时, 重发

RTT (Round-Trip Time 往返时延): 来回时间
RTO (Retransmission Timeout 超时重传时间): 内核重传定时器间隔 (动态计算出来的)

RTO > RTT, RTO 比较大: 丢包后重发等待时间长, 效率低
RTO < RTT, RTO 比较小: 误判丢包, 导致内核过多的重发 以及 网络中滞留过多的重发报文, 阻塞网络, 从而触发更多的重发

理论上 超时重传时间 RTO 的值应该 稍微大于报文往返 RTT 的值;
    "大于" 的一部分本质上是 对端内核的响应时间

动态 RTO 计算
+ 基本思路
    1. 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
    2. 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。
+ RFC6289 公式, 根据采样后的 RTT 时间计算 RTO
2. linux 内核实现, 把 RFC6289 公式的一些常数 给出了具体数值

+ 根据公式
  如果超时重发的数据, 再次超时的时候, 又需要重传的时候, TCP 的策略是"超时间隔加倍"
+ 也就是说
  每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍
  两次超时，就说明网络环境差，不宜频繁反复发送。

## 1.2 快速重传 (Fast Retransmit)
+ 以数据驱动重传, 提前触发重传机制; (避免 超时重传 机制的等待时间过长问题)
+ 机制: 当收到三个相同的 ack, 在定时器到期前, 重传报文
```log
1. 发送方发出了 1，2，3，4，5 份数据：
2. Seq1 先送到了，于是就 Ack 回 2
3. Seq2 因为某些原因没收到，
4. Seq3 到达了, 由于 Seq2 没到, Ack 还是回 2
5. Seq4 和 Seq5 都到了， 由于 Seq2 没到, Ack 还是回 2
6. 发送端收到了三个 Ack = 2 的确认，判定 Seq2 丢失,
   在定时器过期前, 提前重传 Seq2
7. Seq2 到达了, 同时因为 Seq3，Seq4，Seq5 都收到了, Ack 回 6
```

## 1.3 sack
1. 快速重传 解决了 超时时间过长的问题; 但没有解决重传前一个 还是 重传3次ack~当前窗口右边界的所有报文 ?
sack 选择性确认 SACK Selective Acknowledgment 
tcp-option
可以将缓存的 bitmap 返回给发送方, 发送方触发重传机制时, 根据bitmap 选择性重传,
而不是盲目地 重传一个  or 重传全部

`echo 1 > /proc/sys/net/ipv4/tcp_sack` 需要双方支持

## 1.4 d-sack
d-sack: Duplicate SACK 
使用了 tcp-option SACK 来告诉 发送方 有哪些数据被重复接收了,
从而在 接收方的 ack 丢失场景中, 发送方由此得知是 ack 丢失了, 但接收方确实收到了报文, 发送方不再重发
(不过还是会浪费一次重发)

1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

`echo 1 > /proc/sys/net/ipv4/tcp_dsack`

2. 滑动窗口
    1. 发送窗口
    2. 接收窗口
3. 流量控制
    1. 内核缓冲区 和 滑动窗口的关系
    2. 窗口关闭
    3. 糊涂窗口综合症
4. 拥塞控制
    1. 慢启动
    2. 拥塞避免
    3. 拥塞发生
    4. 快速恢复




