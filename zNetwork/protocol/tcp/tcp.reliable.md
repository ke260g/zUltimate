[TOC]
https://www.cnblogs.com/xiaolincoding/p/12732052.html

# 1. 重传机制
1. 超时重传 和 快速重传 是默认自带的
2. sack 和 dsack 是快速重传基础上扩展出来的, 需要调参

## 1.1 超时重传 ( seq 丢失 / ack 丢失 )
1. seq 丢失: send 方发送的报文在网络中丢失, recv 方没有收到
    1. 发送方等待 ack 超时, 重发
2. ack 丢失: recv 方确实收到报文, 然后发送 ack, 但丢失了
    1. 发送方等待 ack 超时, 重发

RTT (Round-Trip Time 往返时延): 来回时间
RTO (Retransmission Timeout 超时重传时间): 内核重传定时器间隔 (动态计算出来的)

RTO > RTT, RTO 比较大: 丢包后重发等待时间长, 效率低
RTO < RTT, RTO 比较小: 误判丢包, 导致内核过多的重发 以及 网络中滞留过多的重发报文, 阻塞网络, 从而触发更多的重发

理论上 超时重传时间 RTO 的值应该 稍微大于报文往返 RTT 的值;
    "大于" 的一部分本质上是 对端内核的响应时间

动态 RTO 计算
+ 基本思路
    1. 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
    2. 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。
+ RFC6289 公式, 根据采样后的 RTT 时间计算 RTO
2. linux 内核实现, 把 RFC6289 公式的一些常数 给出了具体数值

+ 根据公式
  如果超时重发的数据, 再次超时的时候, 又需要重传的时候, TCP 的策略是"超时间隔加倍"
+ 也就是说
  每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍
  两次超时，就说明网络环境差，不宜频繁反复发送。

## 1.2 快速重传 (Fast Retransmit)
+ 以数据驱动重传, 提前触发重传机制; (避免 超时重传 机制的等待时间过长问题)
+ 机制: 当收到三个相同的 ack, 在定时器到期前, 重传报文
```log
1. 发送方发出了 1，2，3，4，5 份数据：
2. Seq1 先送到了，于是就 Ack 回 2
3. Seq2 因为某些原因没收到，
4. Seq3 到达了, 由于 Seq2 没到, Ack 还是回 2
5. Seq4 和 Seq5 都到了， 由于 Seq2 没到, Ack 还是回 2
6. 发送端收到了三个 Ack = 2 的确认，判定 Seq2 丢失,
   在定时器过期前, 提前重传 Seq2
7. Seq2 到达了, 同时因为 Seq3，Seq4，Seq5 都收到了, Ack 回 6
```

## 1.3 sack
1. 快速重传 解决了 超时时间过长的问题; 但没有解决重传前一个 还是 重传 "3次deack~当前窗口右边界"的所有报文 ?
sack 选择性确认 SACK Selective Acknowledgment 
tcp-option
可以将缓存的 bitmap 返回给发送方, 发送方触发重传机制时, 根据bitmap 选择性重传,
而不是盲目地 重传一个  or 重传全部

`echo 1 > /proc/sys/net/ipv4/tcp_sack` 需要双方支持

## 1.4 d-sack
d-sack: Duplicate SACK 
使用了 tcp-option SACK 来告诉 发送方 有哪些数据被重复接收了,

blog 中的ack 丢失场景
blog 中的网络延时场景

目的:
1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了
    1. 当发送方重传N次(快速重传 / 超时重传)后, 接收方重发的N次ack终于被收到了
    2. 此时发送方检查 d-sack, 可以得知接收方收到了N次报文, 即可判定 ack 丢了 
2. 可以知道是不是「发送方」的数据包被网络延迟了
    1. 先根据 sack 触发快速重传
    2. 再根据 d-sack 感知刚刚重传的报文, 对端收到了两份, 即第一份发出去的报文网络延时了
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

`echo 1 > /proc/sys/net/ipv4/tcp_dsack`

# 2 滑动窗口
原始问题: 每个数据包都发ack, 包的往返时间越长, 网络的吞吐量会越低
窗口本意: 在往返时间较长的情况下，它也不会降低网络通信的效率
窗口大小: 无需等待确认应答，而可以继续发送数据的最大值
窗口本质: 发送方内核缓存已发送未应答的数据, 根据sack,超时重传机制重传, 收到应答后销毁
累计应答: 发送方窗口前半部分的确实被接收方收到了, 但ack遗失; 当发送方收到后部分ack, 
         发送方即可判定前部分报文已经被接收方接收, 不在等待ack
## 2.1 窗口大小
1. 在 tcp-header-window 字段中只是窗口大小
2. 通常是 接收方 告知 发送方 的接收缓冲区大小
3. 即窗口大小有 接收方 决定, 发送方不能无理由上调缓冲区
4. 实际上 tcp 是全双工的
    1. 本端作为 接收端时 通知peer发送端, 本段接收缓存大小
    2. 本地作为 发送端时 根据peer接收端通知过来的接收缓冲区大小, 调整发送窗口 
## 2.1 发送窗口
1. 通讯过程中可以拆分为4个部分
    1. 已发送 已确认 的数据
    2. 已发送 未确认 的数据
    3. 未发送 但在接收缓存中, 即允许发送
       (这一部分可能为空, 即窗口数据全发了, 但都没有确认)
       这一部分又称为可用窗口
    4. 未发送 但超出接收缓存, 不允许发送
2. 内核协议栈
```c++
struct {
    uint32_t WND; // 指示发送窗口大小, 即 (已发送 未确认 的数据) + (未发送 但在接收缓存中)
    uint8_t *UNA; // 指向的是已发送但未收到确认的第一个字节, tcp-header最开始就是seq, 所以也指向seq
    uint8_t *NXT; // 指向未发送但可发送范围的第一个字节的序列号, 可能指向 NULL
};

```

## 2.2 接收窗口

# 3 流量控制
## 3.1 内核缓冲区 和 滑动窗口的关系
## 3.2 窗口关闭
## 3.3 糊涂窗口综合症

# 4. 拥塞控制
## 4.1 慢启动
## 4.2 拥塞避免
## 4.3 拥塞发生
## 4.4 快速恢复




