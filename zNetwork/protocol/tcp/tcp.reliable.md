[TOC]
https://www.cnblogs.com/xiaolincoding/p/12732052.html

# 1. 重传机制
1. 超时重传 和 快速重传 是默认自带的
2. sack 和 dsack 是快速重传基础上扩展出来的, 需要调参

## 1.1 超时重传 ( seq 丢失 / ack 丢失 )
1. seq 丢失: send 方发送的报文在网络中丢失, recv 方没有收到
    1. 发送方等待 ack 超时, 重发
2. ack 丢失: recv 方确实收到报文, 然后发送 ack, 但丢失了
    1. 发送方等待 ack 超时, 重发

RTT (Round-Trip Time 往返时延): 来回时间
RTO (Retransmission Timeout 超时重传时间): 内核重传定时器间隔 (动态计算出来的)

RTO > RTT, RTO 比较大: 丢包后重发等待时间长, 效率低
RTO < RTT, RTO 比较小: 误判丢包, 导致内核过多的重发 以及 网络中滞留过多的重发报文, 阻塞网络, 从而触发更多的重发

理论上 超时重传时间 RTO 的值应该 稍微大于报文往返 RTT 的值;
    "大于" 的一部分本质上是 对端内核的响应时间

动态 RTO 计算
+ 基本思路
    1. 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
    2. 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。
+ RFC6289 公式, 根据采样后的 RTT 时间计算 RTO
2. linux 内核实现, 把 RFC6289 公式的一些常数 给出了具体数值

+ 根据公式
  如果超时重发的数据, 再次超时的时候, 又需要重传的时候, TCP 的策略是"超时间隔加倍"
+ 也就是说
  每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍
  两次超时，就说明网络环境差，不宜频繁反复发送。

## 1.2 快速重传 (Fast Retransmit)
+ 以数据驱动重传, 提前触发重传机制; (避免 超时重传 机制的等待时间过长问题)
+ 机制: 当收到三个相同的 ack, 在定时器到期前, 重传报文
```log
1. 发送方发出了 1，2，3，4，5 份数据：
2. Seq1 先送到了，于是就 Ack 回 2
3. Seq2 因为某些原因没收到，
4. Seq3 到达了, 由于 Seq2 没到, Ack 还是回 2
5. Seq4 和 Seq5 都到了， 由于 Seq2 没到, Ack 还是回 2
6. 发送端收到了三个 Ack = 2 的确认，判定 Seq2 丢失,
   在定时器过期前, 提前重传 Seq2
7. Seq2 到达了, 同时因为 Seq3，Seq4，Seq5 都收到了, Ack 回 6
```

## 1.3 sack
1. 快速重传 解决了 超时时间过长的问题; 但没有解决重传前一个 还是 重传 "3次deack~当前窗口右边界"的所有报文 ?
sack 选择性确认 SACK Selective Acknowledgment 
tcp-option
可以将缓存的 bitmap 返回给发送方, 发送方触发重传机制时, 根据bitmap 选择性重传,
而不是盲目地 重传一个  or 重传全部

`echo 1 > /proc/sys/net/ipv4/tcp_sack` 需要双方支持

## 1.4 d-sack
d-sack: Duplicate SACK 
使用了 tcp-option SACK 来告诉 发送方 有哪些数据被重复接收了,

blog 中的ack 丢失场景
blog 中的网络延时场景

目的:
1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了
    1. 当发送方重传N次(快速重传 / 超时重传)后, 接收方重发的N次ack终于被收到了
    2. 此时发送方检查 d-sack, 可以得知接收方收到了N次报文, 即可判定 ack 丢了 
2. 可以知道是不是「发送方」的数据包被网络延迟了
    1. 先根据 sack 触发快速重传
    2. 再根据 d-sack 感知刚刚重传的报文, 对端收到了两份, 即第一份发出去的报文网络延时了
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

`echo 1 > /proc/sys/net/ipv4/tcp_dsack`

# 2 滑动窗口
原始问题: 每个数据包都发ack, 包的往返时间越长, 网络的吞吐量会越低
窗口本意: 在往返时间较长的情况下，它也不会降低网络通信的效率
窗口大小: 无需等待确认应答，而可以继续发送数据的最大值
窗口本质: 发送方内核缓存已发送未应答的数据, 根据sack,超时重传机制重传, 收到应答后销毁
累计应答: 发送方窗口前半部分的确实被接收方收到了, 但ack遗失; 当发送方收到后部分ack, 
         发送方即可判定前部分报文已经被接收方接收, 不在等待ack
## 2.1 窗口大小
1. 在 tcp-header-window 字段中只是窗口大小
2. 通常是 接收方 告知 发送方 的接收缓冲区大小
3. 即窗口大小有 接收方 决定, 发送方不能无理由上调缓冲区
4. 实际上 tcp 是全双工的
    1. 本端作为 接收端时 通知peer发送端, 本段接收缓存大小
    2. 本地作为 发送端时 根据peer接收端通知过来的接收缓冲区大小, 调整发送窗口 
5. 接收窗口的大小是约等于发送窗口的大小的 ( 不完全相等 )
    1. 滑动窗口并不是一成不变的
    2. 当接收方用户态进程 读取速度非常快，接收窗口可以很快地空缺出来
    3. 此时新的接收窗口通过 tcp-header-window 告知发送方;
    4. 这个告知报文存在 网络时延; 所以同一时间中并不完全相等; 但稳定是确实是相同的
## 2.1 发送窗口
1. 通讯过程中可以拆分为4个部分
    1. 已发送 已确认 的数据
    2. 已发送 未确认 的数据
    3. 未发送 但在接收缓存中, 即允许发送
       (这一部分可能为空, 即窗口数据全发了, 但都没有确认)
       这一部分又称为可用窗口
    4. 未发送 但超出接收缓存, 不允许发送
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示发送窗口大小, 即 (已发送 未确认 的数据) + (未发送 但在接收缓存中)
    uint8_t *UNA; // 指向的是已发送但未收到确认的第一个字节, tcp-header最开始就是seq, 所以也指向seq
    uint8_t *NXT; // 指向未发送但可发送范围的第一个字节, 即序列号
};
// 实际运行过程中; 总是满足 UNA <= NXT
```
3. 可用窗口大小 = WND - (NXT - UNA)

## 2.2 接收窗口
1. 通讯过程中可以拆分为4个部分
    1. 已接收 并确认 的数据 (发送窗口也已经确认)
    2. 已接收 并确认 的数据 (发送窗口还没有确认)
    3. 未接收 但允许接收的数据
    4. 未接收 不允许接收的数据
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示接收窗口大小, 即 未接收 但允许接收的数据
    uint8_t *NXT; // 指向待接收的下一个数据字节的第一个字节, tcp-header最开始就是seq, 所以也指向seq
};
```

# 3 流量控制 (这部分建议看blog)
1. 让"发送方"根据"接收方"的实际接收能力控制发送的数据量
    + 避免发送太快; 导致处理不了; 发送方收不到ack 产生重传
+ 避免发送方"填满"接收方的缓存
## 3.1 内核缓冲区 和 滑动窗口的关系
+ 本质:
    1. 接收方窗口大小 = 内核缓冲区 - 已接收但用户进程未读取
    2. 接收方收到 大于 窗口大小的报文将丢弃; 且不告知发送方
1. 正常场景: 接收方用户进程秒读
2. 异常场景: 发送窗口和接收窗口都变为零 (接收方用户进程处理慢)
3. 异常场景: 发送方"可用窗口大小"变为负 (接收方人为缩小缓冲区; 导致窗口缩小 但此时发送方"已发送未确认数据"较多)
    1. 这样会导致丢包; 因为接收方缩小了窗口, 导致发送游离在网络中的报文在到达后, 直接丢弃, 且发送方不知
    2. 且发送方出现诡异的"可用窗口为负"

### 3.1.1 "可用窗口为负" 的问题解决方案
1. 不可以直接缩小缓冲区
2. 正确的做法是, 先缩小窗口, 等待若干报文交互, 再缩小缓冲区

## 3.2 窗口关闭
1. 当窗口大小为零; 发送方暂停给接收方发送数据; 直到窗口变为非 0 为止
2. 正常场景中当接收方 用户进程终于处理完数据; 通过ack 告知发送方 窗口重开
3. 但是这个ack 在网络中丢失; 那么发送方将无法重开窗口; 一直假死等待
4. 发送方超过一个 "窗口嗅探" 定时器间隔后; 发送 "窗口嗅探" 报文
5. 接收方重新把窗口大小 告知  发送方 (ack 报文)
6. 发送方重开窗口
7. 如果超过次数的"窗口嗅探"没有响应; 发送方则发出 RST；并重置连接

### 3.2.1 零窗口攻击
 
## 3.3 糊涂窗口综合症 (建议看原始blog)
1. 问题描述
    1. 如果接收方一直没有读取数据; 导致发送窗口越来越小
    2. 到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，
       而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。
2. 问题本质是性能消耗: 导致发送方发了 tcp+ip头 却携带了少量字节; 浪费网络性能
2. 解决方法
    1. 让接收方不通告小窗口给发送方
    2. 让发送方避免发送小数据
### 接收方不通告小窗口 (提前关闭)
1. 接收方提前关闭窗口: 当 `窗口大小 < min( MSS，缓存空间/2 )` 提前关闭窗口
2. 等到接收方处理了一些数据后，窗口大小 >= MSS，
   or 接收方缓存空间的 1/2可以用了，
   就可以把窗口重新打开
### 让发送方避免发送小数据 (Nagle 算法; 粘包)
1. 限制发包条件; 当满足下列两个条件之一才能发包
    1. 窗口大小 >= MSS or 数据大小 >= MSS 才允许发包
    2. 收到之前已发送数据的 ack
2. Nagle 算法 旧版本的内核默认打开; 没有sysctl 参数控制
    1. 新版本内核已经关闭了
3. socket 开关 Nagle 算法
```c++
int value = 0; // 打开设置为 1
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&value, sizeof(value));
```

# 4. 拥塞控制
1. 避免发送方"填满"整个网络
2. 发送方维护一个"拥塞窗口"
    1. 与接收方无关
    2. 网络的拥塞程度动态变化的
3. 最终影响发送窗口 `swnd = min(cwnd, rwnd)`
    1. 只要网络中没有拥塞，cwnd 增大
    2. 一旦网络中出现拥塞，cwnd 减少
4. 拥塞判定: 产生了超时重传 or 快速重传
5. 拥塞控制算法 = 慢启动 / 拥塞避免 / 拥塞发生 / 快速恢复
## 4.1 慢启动 (RFC2581 第 3 页)
1. 刚建立连接后; 逐步的提高发送数据包的数量;
2. 连接建立完成后, 初始化 cwnd = 1
3. 发送方每接收一个 ack, cwnd++; 
    1. 第一次只能发送一个 seg;
    2. 收到一个 ack; cwnd += 1;  (cwnd == 2)
    3. 第二次可以发送两个 seg
    4. 收到两个 ack; cwnd += 2; （cwnd == 4)
    5. 即每次发送 cwnd 个报文; 收到 ack 后(MSS时间)增长 cwnd
4. 实际上 cwnd 是以2的指数次方增长的
5. 最终上涨到 `cwnd >= ssthresh` 则开始使用 拥塞避免
    + ssthresh 一般是 65535
## 4.2 拥塞避免 (RFC2581 第5页)
1. `cwnd >= ssthresh` 后开始启动
2. 每当收到一个 ACK 时，cwnd += 1/cwnd
    1. 发送 cwnd 个 seg
    2. 收到 cwnd 个 ack; cwnd += 1;
    3. 发送 cwnd 个 seg
    4. 收到 cwnd 个 ack; cwnd += 1;
    5. 即每次发送 cwnd 个报文; 收到 ack 后(MSS时间)增长 1
3. 实际上 cwnd 是系数为 1 的线性增长
## 4.3 拥塞发生
无论 超时重传 或 快速重传; ssthresh 都是 cwnd 减半

### 4.3.1 超时重传 - 拥塞发生
1. 一旦发生超时重传
    1. `ssthresh = cwnd/2;`
    2. `cwnd = 1;`
2. 然后重新开始慢启动
3. Note: 在应对偶发超时的场景中, 该调整过于激进, 最终导致网络卡顿, 影响吞吐量
### 4.3.2 快速重传 - 拥塞发生
1. 一旦发生拥塞重传
    1. `ssthresh = cwnd/2;`
    2. `cwnd = cwnd/2;`
    3. 进入快速恢复算法
+ 快速重传的理论依据:
    1. 还能收到 3 个重复 ACK
    2. 说明网络也不那么糟糕
    3. 所以没有必要像RTO超时重传 那么激进
## 4.4 快速恢复
1. `cwnd = ssthresh + 3;` // 3表示收到了3个ack
2. 重传丢失的数据包；
3. 再收到重复的 ack; 则 `cwnd++;`
4. 如果收到新的 ack;
    1. `cwnd = ssthresh;`
    2. 进入"拥塞避免"
+ 快速恢复的理论依据:
    1. 能发生快速重传; 说明网络不是很糟糕
    2. 一旦收到新的ack; 可以认为网络只是短暂拥塞
    3. 可以马上恢复到"拥塞避免"

```sh
慢启动 ---> 拥塞避免 --> 拥塞发生-超时重传 -> 快速恢复
 ^            |  ^                                |
 |            |  |                                |
 |            v  *--------------------------------*
 |           拥塞发生-超时重传
 |            |
 *------------*
```