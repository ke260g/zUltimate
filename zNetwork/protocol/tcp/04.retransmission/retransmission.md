
# 超时重传 ( seq + ack )
+ 三种情况 (正常 发送方的包未到达接收方 接收方的ack未到达发送方)
+ 发送方 针对长时间没收到ack的包 重发
+ 接收方 针对重复收到的已经发过ack的seq包 重新发ack
+ 发送方的**等待时长**是动态计算的
  + 首次等待 两倍 往返时长
  + 然后等待 四倍 往返时长
  + 足够多次重发后 直接断开连接
+ 每一对seq + ack 称为一个segment
+ segment大小在三次握手时 确认


# 1. 重传机制
1. 超时重传 和 快速重传 是默认自带的
2. sack 和 dsack 是快速重传基础上扩展出来的, 需要调参

## 1.1 超时重传 ( seq 丢失 / ack 丢失 )
1. seq 丢失: send 方发送的报文在网络中丢失, recv 方没有收到
    1. 发送方等待 ack 超时, 重发
2. ack 丢失: recv 方确实收到报文, 然后发送 ack, 但丢失了
    1. 发送方等待 ack 超时, 重发

RTT (Round-Trip Time 往返时延): 来回时间
RTO (Retransmission Timeout 超时重传时间): 内核重传定时器间隔 (动态计算出来的)

RTO > RTT, RTO 比较大: 丢包后重发等待时间长, 效率低
RTO < RTT, RTO 比较小: 误判丢包, 导致内核过多的重发 以及 网络中滞留过多的重发报文, 阻塞网络, 从而触发更多的重发

理论上 超时重传时间 RTO 的值应该 稍微大于报文往返 RTT 的值;
    "大于" 的一部分本质上是 对端内核的响应时间

动态 RTO 计算
+ 基本思路
    1. 需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化。
    2. 除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况。
+ RFC6289 公式, 根据采样后的 RTT 时间计算 RTO
2. linux 内核实现, 把 RFC6289 公式的一些常数 给出了具体数值

+ 根据公式
  如果超时重发的数据, 再次超时的时候, 又需要重传的时候, TCP 的策略是"超时间隔加倍"
+ 也就是说
  每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍
  两次超时，就说明网络环境差，不宜频繁反复发送。

## 1.2 快速重传 (Fast Retransmit)
+ 以数据驱动重传, 提前触发重传机制; (避免 超时重传 机制的等待时间过长问题)
+ 机制: 当收到三个相同的 ack, 在定时器到期前, 重传报文
```log
1. 发送方发出了 1，2，3，4，5 份数据：
2. Seq1 先送到了，于是就 Ack 回 2
3. Seq2 因为某些原因没收到，
4. Seq3 到达了, 由于 Seq2 没到, Ack 还是回 2
5. Seq4 和 Seq5 都到了， 由于 Seq2 没到, Ack 还是回 2
6. 发送端收到了三个 Ack = 2 的确认，判定 Seq2 丢失,
   在定时器过期前, 提前重传 Seq2
7. Seq2 到达了, 同时因为 Seq3，Seq4，Seq5 都收到了, Ack 回 6
```

## 1.3 sack
1. 快速重传 解决了 超时时间过长的问题; 但没有解决重传前一个 还是 重传 "3次deack~当前窗口右边界"的所有报文 ?
sack 选择性确认 SACK Selective Acknowledgment 
tcp-option
可以将缓存的 bitmap 返回给发送方, 发送方触发重传机制时, 根据bitmap 选择性重传,
而不是盲目地 重传一个  or 重传全部

`echo 1 > /proc/sys/net/ipv4/tcp_sack` 需要双方支持

## 1.4 d-sack
d-sack: Duplicate SACK 
使用了 tcp-option SACK 来告诉 发送方 有哪些数据被重复接收了,

blog 中的ack 丢失场景
blog 中的网络延时场景

目的:
1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了
    1. 当发送方重传N次(快速重传 / 超时重传)后, 接收方重发的N次ack终于被收到了
    2. 此时发送方检查 d-sack, 可以得知接收方收到了N次报文, 即可判定 ack 丢了 
2. 可以知道是不是「发送方」的数据包被网络延迟了
    1. 先根据 sack 触发快速重传
    2. 再根据 d-sack 感知刚刚重传的报文, 对端收到了两份, 即第一份发出去的报文网络延时了
3. 可以知道网络中是不是把「发送方」的数据包给复制了;

`echo 1 > /proc/sys/net/ipv4/tcp_dsack`