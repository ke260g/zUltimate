[TOC]
https://www.cnblogs.com/xiaolincoding/p/12732052.html

# 2 滑动窗口
原始问题: 每个数据包都发ack, 包的往返时间越长, 网络的吞吐量会越低
窗口本意: 在往返时间较长的情况下，它也不会降低网络通信的效率
窗口大小: 无需等待确认应答，而可以继续发送数据的最大值
窗口本质: 发送方内核缓存已发送未应答的数据, 根据sack,超时重传机制重传, 收到应答后销毁
累计应答: 发送方窗口前半部分的确实被接收方收到了, 但ack遗失; 当发送方收到后部分ack, 
         发送方即可判定前部分报文已经被接收方接收, 不在等待ack
## 2.1 窗口大小
1. 在 tcp-header-window 字段中只是窗口大小
2. 通常是 接收方 告知 发送方 的接收缓冲区大小
3. 即窗口大小有 接收方 决定, 发送方不能无理由上调缓冲区
4. 实际上 tcp 是全双工的
    1. 本端作为 接收端时 通知peer发送端, 本段接收缓存大小
    2. 本地作为 发送端时 根据peer接收端通知过来的接收缓冲区大小, 调整发送窗口 
5. 接收窗口的大小是约等于发送窗口的大小的 ( 不完全相等 )
    1. 滑动窗口并不是一成不变的
    2. 当接收方用户态进程 读取速度非常快，接收窗口可以很快地空缺出来
    3. 此时新的接收窗口通过 tcp-header-window 告知发送方;
    4. 这个告知报文存在 网络时延; 所以同一时间中并不完全相等; 但稳定是确实是相同的
## 2.1 发送窗口
1. 通讯过程中可以拆分为4个部分
    1. 已发送 已确认 的数据
    2. 已发送 未确认 的数据
    3. 未发送 但在接收缓存中, 即允许发送
       (这一部分可能为空, 即窗口数据全发了, 但都没有确认)
       这一部分又称为可用窗口
    4. 未发送 但超出接收缓存, 不允许发送
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示发送窗口大小, 即 (已发送 未确认 的数据) + (未发送 但在接收缓存中)
    uint8_t *UNA; // 指向的是已发送但未收到确认的第一个字节, tcp-header最开始就是seq, 所以也指向seq
    uint8_t *NXT; // 指向未发送但可发送范围的第一个字节, 即序列号
};
// 实际运行过程中; 总是满足 UNA <= NXT
```
3. 可用窗口大小 = WND - (NXT - UNA)

## 2.2 接收窗口
1. 通讯过程中可以拆分为4个部分
    1. 已接收 并确认 的数据 (发送窗口也已经确认)
    2. 已接收 并确认 的数据 (发送窗口还没有确认)
    3. 未接收 但允许接收的数据
    4. 未接收 不允许接收的数据
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示接收窗口大小, 即 未接收 但允许接收的数据
    uint8_t *NXT; // 指向待接收的下一个数据字节的第一个字节, tcp-header最开始就是seq, 所以也指向seq
};
```