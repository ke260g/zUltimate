[TOC]
拥塞控制
1. 避免发送方"填满"整个网络
2. 发送方维护一个"拥塞窗口"
    1. 与接收方无关
    2. 网络的拥塞程度动态变化的
3. 最终影响发送窗口 `swnd = min(cwnd, rwnd)`
    1. 只要网络中没有拥塞，cwnd 增大
    2. 一旦网络中出现拥塞，cwnd 减少
4. 拥塞判定: 产生了超时重传 or 快速重传
5. 拥塞控制算法 = 慢启动 / 拥塞避免 / 拥塞发生 / 快速恢复

# 1 慢启动 (RFC2581 第 3 页)
1. 刚建立连接后; 逐步的提高发送数据包的数量;
2. 连接建立完成后, 初始化 cwnd = 1
3. 发送方每接收一个 ack, cwnd++; 
    1. 第一次只能发送一个 seg;
    2. 收到一个 ack; cwnd += 1;  (cwnd == 2)
    3. 第二次可以发送两个 seg
    4. 收到两个 ack; cwnd += 2; （cwnd == 4)
    5. 即每次发送 cwnd 个报文; 收到 ack 后(MSS时间)增长 cwnd
4. 实际上 cwnd 以2的指数次方增长的
5. 最终上涨到 `cwnd >= ssthresh` 则开始使用 拥塞避免
    + ssthresh 一般是 65535

# 2 拥塞避免 (RFC2581 第5页)
1. `cwnd >= ssthresh` 后开始启动
2. 每当收到一个 ACK 时，cwnd += 1/cwnd
    1. 发送 cwnd 个 seg
    2. 收到 cwnd 个 ack; cwnd += 1;
    3. 发送 cwnd 个 seg
    4. 收到 cwnd 个 ack; cwnd += 1;
    5. 即每次发送 cwnd 个报文; 收到 ack 后(MSS时间)增长 1
3. 实际上 cwnd 以1的系数线性增长

# 3 拥塞发生
无论 超时重传 或 快速重传; ssthresh 都是 cwnd 减半
## 3.1 超时重传 - 拥塞发生
1. 一旦发生超时重传
    1. `ssthresh = cwnd/2;`
    2. `cwnd = 1;`
2. 然后重新开始慢启动
3. Note: 在应对偶发超时的场景中, 该调整过于激进, 最终导致网络卡顿, 影响吞吐量
## 3.2 快速重传 - 拥塞发生
1. 一旦发生拥塞重传
    1. `ssthresh = cwnd/2;`
    2. `cwnd = cwnd/2;`
    3. 进入快速恢复算法
+ 快速重传的理论依据:
    1. 还能收到 3 个重复 ACK
    2. 说明网络也不那么糟糕
    3. 所以没有必要像RTO超时重传 那么激进

# 4 快速恢复
1. `cwnd = ssthresh + 3;` // 3表示收到了3个ack
    + 因为是从 快速重传 状态切过来的, 实际上收到第三个ack后 `cwnd = cwnd/2 + 3;`
2. 重传丢失的数据包;
3. 再收到重复的 ack; 则 `cwnd++;` (2的指数次方增长)
4. 如果收到新的 ack;
    1. `cwnd = ssthresh;` (这个 ssthresh, 就是快速重传切进来时 `sshresh = cwnd/2` )
    2. 进入"拥塞避免"
+ 快速恢复的理论依据:
    1. 能发生快速重传; 说明网络不是很糟糕
    2. 一旦收到新的ack; 可以认为网络只是短暂拥塞
    3. 可以马上恢复到"拥塞避免"

```sh
慢启动 ---> 拥塞避免 --> 拥塞发生-超时重传 -> 快速恢复
 ^            |  ^                                |
 |            |  |                                |
 |            |  *--------------------------------*
 |            v
 |           拥塞发生-超时重传
 |            |
 *------------*
```

# 5. 总结
## 5.1 拥塞窗口大小变化模式
1. 慢启动:   随时间以2的指数次方增长
2. 拥塞避免: 随时间以1的系数线性增长
3. 拥塞发生:
    1. 超时重传: 跌回1, 重新开始慢启动, ssthresh = cwnd/2;
    2. 快速重传: ssthresh = cwnd/2; cwnd /= 2;
4. 快速恢复: cwnd = sshresh+3
    1. 收到重复 ack; 则以2的指数次方增长
    2. 收到新的 ack; `cwnd = ssthresh;` 则进入拥塞避免