[TOC]
https://blog.csdn.net/yao5hed/article/details/81046945

# 1. 基本原理
1. 原始问题: 每个数据包都发ack, 包的往返时间越长, 网络的吞吐量会越低
2. 解决方案:
    1. 发送端和接收端分别定义一个大小为N的窗口
    2. 发送段 一次发送N个报文段, 同时等待N个ack
    3. 接收端 允许接收N个报文段, 收到报文后发送已接收连续的最大ack

3. 设计目的: 在往返时间较长的情况下，它也不会降低网络通信的效率
4. 窗口大小: 无需等待确认应答，而可以继续发送数据的最大值
5. 窗口本质: 发送方内核缓存已发送未应答的数据, 根据sack,超时重传机制重传, 收到应答后销毁
6. 累计应答:
    1. 发送方窗口前半部分的确实被接收方收到了, 但ack遗失; 当发送方收到后部分ack, 
    2. 发送方即可判定前部分报文已经被接收方接收, 不在等待ack

# 2. 窗口大小
1. 在 tcp-header-window 字段中只是窗口大小
2. 通常是 接收方 告知 发送方 的接收缓冲区大小
3. 即窗口大小有 接收方 决定, 发送方不能无理由上调缓冲区
4. 实际上 tcp 是全双工的
    1. 本端作为 接收端时 通知peer发送端, 本段接收缓存大小
    2. 本地作为 发送端时 根据peer接收端通知过来的接收缓冲区大小, 调整发送窗口 
5. 接收窗口大小 不完全相等 发送窗口大小 (存在网络时延)
    1. 滑动窗口并不是一成不变的
    2. 当接收方用户态进程 读取速度非常快，接收窗口可以很快地空缺出来
    3. 此时新的接收窗口通过 tcp-header-window 告知发送方;
    4. 这个告知报文存在 网络时延; 所以同一时间中并不完全相等; 但稳定是确实是相同的
6. 窗口大小不能大于序列号空间的一半
    + 目的: 为了不让两个窗口出现交迭

# 3. 发送窗口
1. 发送窗口机制
  1. 同一窗口中的segment 即使上一段没有收到ACK 也继续发
  2. 窗口中**第**m个segment的ack收到后 即可把窗口 往后移m个segment
  3. 当**第**m个segment的ack收到后; 当作 0 ~ m-1 个segment的ack收到; 即使没收到也无需重发
  4. 避免因ack丢失 导致的冗余重发
  5. 当**第**n个segment的ack重复收到 表明该segment的下一segment丢失, 但不能确定下下segment是否丢失
2. 数据可以拆分为4个部分
    1. 已发送 已确认 的数据 (在窗口前)
    2. 已发送 未确认 的数据 (在窗口中)
    3. 未发送 但在接收缓存中, 即允许发送 (在窗口中)
       (这一部分可能为空, 即窗口数据全发了, 但都没有确认)
       这一部分又称为可用窗口
    4. 未发送 但超出接收缓存, 不允许发送 (在窗口后)
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示发送窗口大小, 即 (已发送 未确认 的数据) + (未发送 但在接收缓存中)
    uint8_t *UNA; // 指向的是已发送但未收到确认的第一个字节, tcp-header最开始就是seq, 所以也指向seq
    uint8_t *NXT; // 指向未发送但可发送范围的第一个字节, 即序列号
};
// 实际运行过程中; 总是满足 UNA <= NXT
```
3. 可用窗口大小 = WND - (NXT - UNA)

# 4. 接收窗口
1. 接收窗口机制 (移动窗口 + 发送首个非连续处segment的ack)
  1. 同一窗口中的segment 当第i个segment没有收到 但收到了其后i+1, i+2的segment
  2. 这时 接受端 每次收到i + j的segment时, 发第i个ack
  3. 直到收到 i个segment后, 且窗口中segment完全连续时 发送最末端ack
  4. 对于收到重复的seq包 依旧根据上面机制发送 ack 包
2. 数据可以拆分为4个部分
    1. 已接收 并确认 的数据 (发送窗口也已经确认) (在窗口前)
    2. 已接收 并确认 的数据 (发送窗口还没有确认) (在窗口中)
    3. 未接收 但允许接收的数据 (在窗口中)
    4. 未接收 不允许接收的数据 (在窗口后)
2. 内核协议栈实现
```c++
struct {
    uint32_t WND; // 指示接收窗口大小, 即 未接收 但允许接收的数据
    uint8_t *NXT; // 指向待接收的下一个数据字节的第一个字节, tcp-header最开始就是seq, 所以也指向seq
};
```

# 5. 收发窗口的区别
1. 发送窗口一旦收到窗口内segment任意ack；就会右移发送窗口
2. 接收窗口只有收到窗口左边界开始连续的k个segment; 才会右移接收窗口k (k >= 1)
    1. 当窗口内较前segment未接收; 但提前收到窗后内较后方的segment窗口不会移动
    2. 且不对窗口内靠后segment发送ack。而是重发左边界-1的ack。
    3. 以此确保对端会对窗口内所有segment重传
+ 这种区别的本质是为了 同步两端的窗口左边界

# 6. 收发场景
1. 接收方和发送方窗口是左边界同步
2. 现发送方把窗口内所有 segment 发送
3. 会有如下几个场景

## 场景1: 窗口内segment 接收方全部接收; 发送方全收到最后segment的ack
1. 接收方和发送方同时把窗口右移

## 场景2: 窗口内segment 接收方全部接收; 但是ack全部丢掉了
1. 接收方全部接收后; 窗口右移
2. 发送方等待ack超时; 重发窗口内的segment
3. 接收方收到 当前接收窗口左边界之前的 segment；重发左边界-1的ack
4. 发送方收到 ack后右移窗口

## 场景3: 窗口内segment 接收方提前收到较后部分
设提前收到 m+1 ~ N 的segment; 窗口大小为N
1. 接收方没有收到 左边界~m 的segment; 只发送左边界-1的ack
2. 发送方等待ack超时；重发 1~N 的segment

## 场景4: 窗口内segment 接收方只接收到前半部分(连续的)
设只收到 m 个segment, 窗口大小N
1. 接收方只发送第 m 个segment的ack; 窗口右移 m
2. 发送方收到第k个segment的ack; 窗口也右移k
3. 发送方 发送的 m-N个segment超时重发