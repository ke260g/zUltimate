[TOC]
1. 流量控制是为了让"发送方"根据"接收方"的实际接收能力控制发送的数据量
    + 避免发送太快; 导致处理不了; 发送方收不到ack 产生重传
+ 避免发送方"填满"接收方的缓存

# 1. 内核缓冲区 和 滑动窗口的关系
+ 本质:
    1. 接收方窗口大小 = 内核缓冲区 - 已接收但用户进程未读取
    2. 接收方收到 大于 窗口大小的报文将丢弃; 且不告知发送方
1. 正常场景: 接收方用户进程秒读
2. 异常场景: 发送窗口和接收窗口都变为零 (接收方用户进程处理慢)
3. 异常场景: 发送方"可用窗口大小"变为负 (接收方人为缩小缓冲区; 导致窗口缩小 但此时发送方"已发送未确认数据"较多)
    1. 这样会导致丢包; 因为接收方缩小了窗口, 导致发送游离在网络中的报文在到达后, 直接丢弃, 且发送方不知
    2. 且发送方出现诡异的"可用窗口为负"

## 1.1 "可用窗口为负" 的问题解决方案
1. 不可以直接缩小缓冲区
2. 正确的做法是, 先缩小窗口, 等待若干报文交互, 再缩小缓冲区

# 2. 窗口关闭
1. 当窗口大小为零; 发送方暂停给接收方发送数据; 直到窗口变为非 0 为止
2. 正常场景中当接收方 用户进程终于处理完数据; 通过ack 告知发送方 窗口重开
3. 但是这个ack 在网络中丢失; 那么发送方将无法重开窗口; 一直假死等待
4. 发送方超过一个 "窗口嗅探" 定时器间隔后; 发送 "窗口嗅探" 报文
5. 接收方重新把窗口大小 告知  发送方 (ack 报文)
6. 发送方重开窗口
7. 如果超过次数的"窗口嗅探"没有响应; 发送方则发出 RST；并重置连接

## 2.1 零窗口攻击
 
# 3.  糊涂窗口综合症 (建议看原始blog)
1. 问题描述
    1. 如果接收方一直没有读取数据; 导致发送窗口越来越小
    2. 到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口
       而发送方会义无反顾地发送这几个字节
    3. 最终, 发送方发了 tcp+ip头 却携带了少量字节; 浪费网络性能
2. 解决方法 (从 tcp 设计上解决)
    1. 接收方不通告小窗口, `窗口 < min(mss, 缓冲区大小/2)` 即提前关闭
    2. 发送方不发送小数据, `buffer-size > mss or window-size > mss` 才发送
### 3.1 解决方法a) 接收方不通告小窗口 (提前关闭)
1. 接收方提前关闭窗口: 当 `窗口大小 < min( MSS, 缓存空间/2 )` 提前关闭窗口
2. 等到接收方处理了一些数据后，窗口大小 >= MSS，
   or 接收方缓存空间的 1/2可以用了，
   就可以把窗口重新打开
### 3.2 解决方法b) 发送方不发送小数据 (Nagle 算法; 粘包)
1. 限制发包条件; 当满足下列两个条件之一才能发包
    1. `buffer-size > mss or window-size > mss` 才发送
    2. 收到之前已发送数据的 ack (这是为了 配合接收方关闭窗口-不发 ack, 也是为了取得mss)
2. Nagle 算法 旧版本的内核默认打开; 没有sysctl 参数控制
    1. 新版本内核已经关闭了
3. socket 开关 Nagle 算法
```c++
int value = 0; // 打开设置为 1
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&value, sizeof(value));
```