## Q: 进程和线程有什么不同 (执行 /  资源(地址空间) / 通讯 / 健壮性)
1. 进程是资源分配的最小单元; 线程是程序执行的最小单元
2. 进程有自己的独立地址空间; 而线程是共享进程中的数据(??)
    1. 一系列的页表(task_struct->mm_struct 链表) 维护代码段 堆栈段
    2. 分配页表的操作是昂贵的(建立 MMU的映射关系; 内存分配算法)
    3. 因此; CPU切换线程的开销 远比 进程的开销要小很多
3. 线程间通讯比进程间通讯更快速; 因为线程间共享 全局变量, 静态变量
   进程间通讯则需要更昂贵的代价: 比如网络、共享内存、信号量、消息队列
4. 多进程比多线程更健壮
    1. 因为一个线程挂掉了, 会导致线程都挂掉(共享地址空间)
    2. 反之一个进程挂掉了, 并不会对另一个进程造成很大影响

## Q: 进程和线程分别共享了哪些资源


## Q: linux 进程的内存空间分布 (/proc/$pid/maps 从低到高)
1. 代码段 elf .text segment
2. 数据段 elf .bss .data .rodata
    + 数据段与brk不是直接相邻的;      brk-offset
3. Heap 堆内存;       往高地址增长
    + Heap 和 mmap 不是直接相邻的
4. mmap 的动态链接库; 往高地址增长 （往栈底方向增长)
    + mmap域与栈不是直接相邻的;       mmap-offset
5. Stack 栈内存; 往低地址增长 (`%esp 指针`)
    + Stack 和 Kernel 不是直接相邻的; stack-offset 
6. Kernal Space: 可在编译时调整; 默认是1G
   

## Q: 内存溢出　内存泄漏　内存越界的区别? 什么是野指针
1. 内存泄漏: memory-leak; 程序申请内存后; 无法释放已经申请的内存空间
2. 内存越界: 程序访问超出既定访问的内存数据
3. 内存溢出: out-of-memory; 用户态程序向内核态申请内存时; 没有足够的存储空间　(OOM)

## Q: 进程中堆栈内存的区别
| 区别点 | 栈  |  堆 |
| :-:    | :-: | :-: |
| 管理方式 | 编译器自动管理 | 动态申请; 需要手动释放 |
| 空间大小 | 连续的 往低地址增长 | 不连续 往高地址增长(mm 用链表进行管理) |
| 碎片问题 | 没有 | 频繁申请和释放内存 会造成大量碎片 |
| 增长方式 | 往低地址增长 | 往高地址增长 |
| 分配方式 | fork阶段完成后; 运行过程中编译器完成 | 动态分配 |
| 分配效率 | 若干个指令的消耗 | 根据复杂的分配机制完成; 当碎片化严重时需要重新整理内存空间；毫秒级耗时 |

## Q: fork 做了啥

## Q: vfork 做了啥

## Q: clone 做了啥