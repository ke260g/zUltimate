[TOC]
白话文简单易懂 https://www.cnblogs.com/xiaolincoding/p/13289992.html
1. 程序: 放在 disk 中的静态二进制文件
2. 进程: 装载进内存中, 正在运行的程序
3. 线程: 进程中其中一个执行单元
4. 并发: 多个进程, 交替执行 (产出并行的错觉)
5. 并行: 多个线程, 同时执行
6. 进程or线程的 3种基本状态: 就绪 / 阻塞 / 运行
7. 进程or线程的 本质区别: 线程是调度执行的基本单位，而进程则是资源管理的基本单位
8. 调度: 控制进程 什么时候?运行多久?

# 1. 进程
## 1.1 进程概念


## 1.2 进程状态机 (7 种)
```txt
               +-----------------------------+             +-----+
/------------- |           运行              | -- 退出  ->  | 退出 | 
 |             +-----------------------------+             +-----+
 |                ^     |                  | 
 |                |     |                  |
 |               调度   时间片耗尽        等待事件
 |                |     |                  |
 |                |     v                  v
 |               +------+               +------+
 |   /---------> | 就绪 | <- 事件完成 -- | 阻塞 | 
 |      |        +------+               +------+
 |      |         ^    |                 ^    |                
 |   +-----+      |    |                 |    |
 |   | 创建 |    激活 挂起               激活 挂起
 |   +-----+      |    |                 |    |
 |      |         |    v                 |    v
 |      |        +------+               +------+
 |      \----->  | 挂起 | <- 事件出现 -- | 挂起 |
 |               +------+               +------+
 |                   ^
 |                   |
\--------------------/
```

## 1.3 进程空间块 PCB (Process Control Block)
### 1.3.1 基本信息
1. 描述信息: 进程id, 用户id
2. 控制信息: 状态, 优先级
3. 资源信息: fd, mm
4. cpu 信息: cpu 各个寄存器的值, 用于进程调度前保存现场, 重新调度恢复现场
### 1.3.2 组织方式
1. 以链表的方式连接
    1. 就绪队列
    2. 阻塞队列
2. 以红黑树形式存放在调度器中

## 1.4 进程控制
### 1.4.1 创建进程 fork()
1. 分配 pid
2. malloc pcb
3. 分配资源, 如果资源, 则等待
4. 初始化 pcb
5. 如果就绪队列有位置, 加入到就绪队列中

### 1.4.2 终止进程
1. 根据 pid 找到 pcb
2. 如果正在运行, 则立即终止进程的执行, 然后调度其他进程
3. 如果有子进程, 则将子进程终止
4. 将该进程拥有的全部资源归还到父进程 or 释放回内核
5. 从进程队列中删除

### 1.4.3 阻塞进程
1. 根据 pid 找到 pcb
2. 如果该进程为运行状态, 保存现场(register), 设置状态为 阻塞, 停止运行 
3. 加入到阻塞队列中

### 1.4.4 唤醒进程
1. 在阻塞队列中找到 pcb
2. 从阻塞队列中移出, 设置为就绪状态
3. 插入就绪队列
4. 调度器重新调度进程

## 1.5 进程切换
1. cpu 上下文切换 过程简述
    1. 先把上一个任务的 cpu 上下文(register and program-counter) 保存
    2. 在把下一个任务的 cpu 上下文(regsiter and program-counter) 恢复
2. cpu 上下文切换 场景分类
    1. 进程上下文
    2. 线程上下文
    3. 中断上下文
3. 进程上下文切换
    1. 虚拟内存切换 (MMU 换表?) { 堆/栈/全局变量 }
    2. CPU 上下文切换
    3. 内核资源上下文切换 (哪些?)

# 2. 线程
## 2.1 线程特性
1. 优点:
    1. 一个线程有多个线程
    2. 各个线程可以同时并行
    3. 各个线程可以共享地址空间和文件等资源
2. 缺点:
    1. 当一个线程崩溃, 会导致进程的所有线程都崩溃
## 2.2 进程与线程对比
1. 进程是资源(内存,文件,套接字,信号回调等)分配的单位; 线程是 CPU 执行调度的单位
2. 进程独享一个完整的资源平台; 线程独享必不可少的资源(如寄存器和栈)
3. 进程和线程同样拥有 就绪、阻塞、执行 三种基本状态
4. 线程可以减少 切换 和 空间的开销

## 2.3 线程比进程轻量的体现
1. 创建时间更快: 省去了创建进程时需要 创建的 内存/文件/信号 等资源
    1. 首个线程必须创建
    2. 后续线程直接共享
2. 终止时间更快: 需要销毁的资源更少
3. 切换时间更快: 不需要切换页表(设置MMU), 因为共享了地址空间
    + 这里的切换指: 1个进程, n 个cpu, m 个线程; m个线程的切换 (n < m)
4. 通讯效率更高: 线程间传递数据, 使用全局变量即可, 甚至不需要切换到内核态
5. 占用空间更少:  因为资源少, 所以使用的内存资源更少, 如少了页表/fd表 等

## 2.4 线程的上下文切换
1. 当两个线程不属于同一个进程, 则切换的过程就跟进程上下文切换一样
2. 当两个线程是属于同一个进程, 只需要切换线程的私有数据, 寄存器等不共享的数据

## 2.5 线程的实现
1. 多个用户线程 <-> 一个内核线程
2. 一个用户线程 <-> 一个内核线程
3. 多个用户线程 <-> 多个内核线程
### 2.5.1 用户线程 (多 对 一)
1. 设计:
    1. 用户态线程库 管理线程, 实现线程控制块(Thread Control Block) 
    2. 用户线程的管理, 由 用户态线程库 负责 (创建/退出/同步/调度)
2. 优点:
    1. 每个进程有私有 线程控制块 列表 TCB; 便于获取 线程状态信息
    2. TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统
3. 缺点:
    1. 操作系统不参与线程调度, 如果一个线程syscall 阻塞了, 导致整个进程都阻塞了
    2. 用户态线程 没法打断 当前运行的线程; 所以只有当一个线程主动 yield, 其他线程才能被调度
    3. 内核时间片是分配给进程的, 那么用户态线程随着数量增多, 执行会变慢 
       (实际上, 内核的线程与进程的优先级同级, 共同分得时间片)

### 2.5.2 内核线程 (一 对 一) (clone 系统调用)
1. 设计
    1. 由 kernel 管理, 线程控制块列表 存放在内核态
    2. 内核线程的管理, 由内核负责 (创建/退出/同步/调用)
2. 优点:
    1. 同一进程中, 一个线程syscall阻塞, 不会影响其他线程
    2. 线程与进程在调度时同级, 执行相对 用户线程 更快
3. 缺点:
    1. 由内核维护 进程/线程 上下文 (PCB, TCB)
    2. 创建/退出/切换 由系统调用进行, 加大了系统的开销

### 2.5.3 轻量线程 (LWP) (Light-Weight Process)
1. LWP 是内核支持的用户线程
2. 一个进程可以有多个 LWP
3. 每个 LWP 与 一个内核态线程 映射
+ LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息
#### 2.5.3.1 1:1 (1 LWP 对应 1用户线程)
优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP
缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大
#### 2.5.3.2 N:1 (1 LWP 对应 N用户线程)
优点：用户线程要开几个都没问题，且上下文切换发生用户空间，切换的效率较高
缺点: 一个用户线程, 同一内核线程的其他用户线程都会阻塞, 用户线程间无并行
#### 2.5.3.3 N:M (M LWP 对应 N用户线程)
综合了  1:1 和 N:1 的优点

# 3. 调度
## 3.1 调度时机
就绪 > 运行: 内核 从就绪队列选择一个进程运行
运行 > 阻塞: 进程阻塞性 syscall, 内核选择其他进程运行
运行 > 退出: 进程退出后, 内核选择其他进程运行

## 3.2 调度原则 (调度算法考虑的因素) (本人认为以下归纳有问题)
1. 原则1(cpu 利用率): 确保 CPU 始终处于匆忙的状态
    1. 进程发起 IO请求, 导致CPU空闲, 调度程序 内核选择其他进程运行
2. 原则2(系统吞吐量):
    1. 吞吐量表示的是单位时间内 CPU 完成进程的数量
    2. 个别进程长期占用 CPU (运算密集型), 降低系统吞吐量
3. 原则3(轮转时间): 降低进程轮转时间
    1. 轮转时间是进程运行和阻塞时间总和
    2. 轮转时间越短越好
4. 原则4(等待时间): 就绪队列中进程等待时间 不能太久
5. 原则5(响应时间): 交互式强的进程响应时间 尽可能短
    1. 用户提交请求到系统第一次产生响应所花费的时间

## 3.3 调度算法
### 3.3.1 先来先服务 (FCFS) (First Come First Severd)
1. 机制:
    1. 每次从就绪队列选择最先进入队列的进程
    2. 一直运行
    3. 直到进程退出 or 阻塞(放到队列最后)
    4. 继续从队列中选择第一个进程接着运行
2. 特点:
    1. cpu 密集型进程, 非常有利, 减少不必要的切换
    2.  io 密集型进程, 造成 cpu 空闲时间太长
### 3.3.2 最短作业优先 (SJF) (Shortest Job First)
1. 机制:
    1. 优先运行 耗时短的进程
2. 特点:
    1. 有效提高系统吞吐量
    2. 如果一直 耗时短的进程, 最终导致 耗时长的进程无法被调度
### 3.3.3 高响应比优先 (HRRN) (Highest Response Ratio Next)
1. 机制:
    1. 需要调度进程时
    2. 先计算 **响应比优先级**
    3. 然后把 **响应比优先级** 最高的进程投入运行
2. 计算公式:
    ```s
             已经等待时间 + 要求服务时间
    优先级 = -------------------------
                   要求服务时间
    ```
    1. 当两进程 已经等待时间相同, 要求服务时间越短, 优先级更高; 即 耗时短的进程 更容易被调度
    2. 当两进程 要求服务时间相同, 已经等待时间越长, 优先级越高; 即 已经等待时间长的进程 终究要被调度, 从而使得 耗时长的进程 也能被调度

### 3.3.4 时间片轮转 (RR) (Round Robin)
1. 机制: (最古老, 最简单, 最公平, 最广泛)
    1. 为每个进程分配一个时间片(Quantum)
    2. 定时(cpu 定时中断)检查当前运行进程已运行时间
    3. 如果当前运行进程 已运行时间 超出 时间片, 则调度走
    4. 如果进程 syscall 阻塞, 则马上调度走
2. 时间片尺度的讨论: (详见内核调度器)
    1. 如果太短, 导致上下分切换频繁, 降低吞吐量
    2. 如果太长, 导致响应时间太长, 不适用与交互

### 3.3.5 最高优先级 (HPF) (Highest Priority First)
1. 机制:
    1. 从就绪队列中选择最高优先级的进程进行运行
    2. 静态优先级: 进程创建时进行设置
    3. 动态优先级: 随着进程运行时间增加, 降低优先级
                   随着进程等待时间增加, 提高优先级
2. 最高优先级 选择方式x2
    1. 非抢占式: 即使出现最高优先级进程, 
       也要等当前进程运行阻塞/退出 后才能调度
    2. 抢占式: 一旦出现最高优先级进程, 
       立即挂起当前进程, 并调度新出现的最高优先级进程

### 3.3.6 多级反馈队列 (Multilevel Feedback Queue)
```s
queue   prio    slice
 q1      p1      s1
 q2      p2      s2
 q3      p3      s3
...      ...     ...
 qn      pn      sn

p1 > p2 > p3 > ... > pn
s1 < s2 < s3 < ... < sn
# 1. 新创建进程, 初始化进入 q1 的末尾
# 2. 由于队列中采取 FCFS 原则, 新进程要等前面的进程完成才能处理 
# 3. 在 s1 时间片内跑不完, 再进入 q2 的末尾
# 4. 在 q2 中有更大的时间片 s2, 但优先级低
# 5. 优先级低的意思是, 可能会被 s1 的抢占
```
1. 机制:
    1. 多级: 多优先级, 每个优先级一个队列, 优先级越高, 时间片越短
    2. 反馈: 当进程加入优先级高的队列时, 立即挂起当前进程, 调度优先级高的进程
    3. 每个优先级队列中, 按照先来先服务FCFS原则运行
    4. 当进程在一个队列中时间片耗尽后还没完成, 则降低进程优先级(使获得更多时间片)
    5. 只有当较高优先级的队列为空，才调度较低优先级的队列中的进程运行
    6. 新创建进程首先进入优先级最高的队列
2. 特性:
    1. 优先处理 耗时短的进程, 因为优先级高
    2. 如果一堆耗时长的进程, 最终都会落到最低优先级, 且时间片最大
    3. 低优先级, 大时间片的进程, 上下切换频率比较低, 增大了吞吐量

## 3.4 调度算法 分析
1. FCFS 部分优先级较大的任务无法被优先响应, 比如遇到紧急处理任务
    + 该任务无法被及时处理, 后果不堪设想
2. SJF  导致耗时长的任务无法被处理, 如果耗时长的任务重要性较高, 比如数据同步, 代价就很大
3. HRRN 需要提前给出任务的处理时间, 最终任务的处理时间由任务设计者提供, 相当复杂
4. RR   时间片轮转虽然综合性能好, 但无法处理 优先级 的问题
    1. 实际上内核的 时间轮转调度器, 通过数学方式, 调整了时间片问题 和 优先级问题
    2. 与原生的时间片轮转调度策略相差较远

    