[TOC]

x86_64系统中，用到了四级页表 (多级分页目录结构)
l  页全局目录(Page Global Directory)
l  页上级目录(Page Upper Directory)
l  页中间目录(Page Middle Directory)
l  页表(Page Table)
# 1. 多级分页目录结构
# 2. 伙伴系统算法 (buddy system)
1. 每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。
2. 最大可以申请1024个连续页框，对应4MB大小的连续内存。
3. 假设要申请一个256个页框的块
    1. 先从256个页框的链表中查找空闲块
    2. 如果没有，就去512个页框的链表中找
    3. 找到了则将页框块分为2个256个页框的块
    4. 一个分配给应用，另外一个移到256个页框的链表中
# 3. slab分配器 ( Solaris 2.4 的分配算法 )
1. slab分配器直接工作于伙伴系统之上
2. slab分配器为每种使用的 "内核对象" 建立单独的缓冲区
3. 每种缓冲区由多个 slab 组成，每个 slab就是一组连续的物理内存页框，被划分成了固定数目的对象。
4. 根据对象大小的不同，缺省情况下一个 slab 最多可以由 1024个页框构成
5. 出于对齐等其它方面的要求，slab 中分配给对象的内存可能大于用户要求的对象实际大小，这会造成一定的内存浪费。

# 4. 内存分配函数比较
| 函数 | 分配原理 | 最大内存 | 适用场景 |
| :-: | :-: | :-: | :-: |
| __get_free_pages / alloc_pages | 直接对页框进行操作，返回线性地址，返回页地址 | 4M | 适用于分配较大量的连续物理内存 |
| kmem_cache_alloc | 基于slab机制实现 | 128KB | 适合需要频繁申请释放相同大小内存块时使用 |
| kmalloc | 基于kmem_cache_alloc实现 | 128KB | 	最常见的分配方式，需要小于页框大小的内存时可以使用 |
| vmalloc | 建立非连续物理内存到虚拟地址的映射 | 无 | 物理不连续，适合需要大内存，但是对地址连续性没有要求的场合 |
| dma_alloc_coherent | 基于__alloc_pages | 4MB | DMA |
| ioremap | 实现已知物理地址到虚拟地址的映射 | 无 | 适用于物理地址已知的场合，如设备驱动 |
| alloc_bootmem | 在启动kernel时，预留一段内存, 启动后内核代码不可再分配/释放 | 无 | 小于物理内存大小，内存管理要求较高 |

alloc_bootmem
 在Linux内核引导时，传入参数“mem＝size”保留顶部的内存区间。
 比如系统有256MB内存，参数“mem＝248M”会预留顶部的8MB内存，进入系统后可以调用ioremap(0xF800000，0x800000)来申请这段内存。
绕过伙伴系统来分配大块内存 (即在调用mem_init 伙伴算法系统初始化之前)
 如果需要在其他地方调用这块内存，可以将alloc_bootmem返回的内存首地址通过EXPORT_SYMBOL导出，然后就可以使用这块内存了