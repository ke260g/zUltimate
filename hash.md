https://oi-wiki.org/string/hash/

## 哈希函数
### 直接定址法; (线性函数)
### 除留余数法; (质数取模)
### 平方取中法;
关键字值的平方，然后取平方值中间几位作为散列地址
### 折叠法
将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。

## 冲突解决
1. 拉链法: 将所有关键字为同义词的结点链接在同一个单链表中。
2. 开发定址法: 使用探测机制在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。
### 拉链法
### 开放定址法 a) 线性探查法
hi=(h(key)+i) ％ m ，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到 有空余地址 或者到 T[d-1]为止。
### 开发定址法 b) 二次探查法
hi=(h(key)+i*i) ％ m，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，T[d+2^2]，T[d+3^2],…，等，直到探查到 有空余地址 或者到 T[d-1]为止。

缺点是无法探查到整个散列空间。
### 开放定址法 c) 双重散列法

hi=(h(key)+i*h1(key)) ％ m，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+h1(d)], T[d + 2*h1(d)]，…，等。

该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。

定义 h1(key) 的方法较多，但无论采用什么方法定义，都必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。

该方法是开放定址法中最好的方法之一。