[TOC]


## 哈希字符串
https://oi-wiki.org/string/hash/
1. 把字符串映射到整数
2. 映射后方便判断两字符串是否相等
    1. 即 hash值 不一样时 字符串一定不相同
    2. 但字符串不相同时, hash 值可以一样 (冲突)
### 版本1: 原始版本
```c++
const int M = 1e9 + 7;
const int B = 233;
int get_hash(const string& s) {
  int res = 0;
  for (int i = 0; i < s.size(); ++i) {
    res = (long long)(res * B + s[i]) % M;
  }
  return res;
}
```
1. (每一个字符 + base * 乘上个字符的摸) 然后取模
2. Base 与 Module 必须互质; 否则槽位 Module 上分布概率不均匀
3. 一般地, Module 会选择较大的质数
### 版本2: 

## 哈希函数
### 直接定址法; (线性函数)
### 除留余数法; (质数取模)
### 平方取中法;
关键字值的平方，然后取平方值中间几位作为散列地址
### 折叠法
将关键字分为位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。

## 冲突解决
1. 拉链法: 将所有关键字为同义词的结点链接在同一个单链表中。
2. 开发定址法: 使用探测机制在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。
### 拉链法
### 开放定址法 a) 线性探查法
hi=(h(key)+i) ％ m ，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1]，…，直到探查到 有空余地址 或者到 T[d-1]为止。
### 开发定址法 b) 二次探查法
hi=(h(key)+i*i) ％ m，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1^2]，T[d+2^2]，T[d+3^2],…，等，直到探查到 有空余地址 或者到 T[d-1]为止。

缺点是无法探查到整个散列空间。
### 开放定址法 c) 双重散列法

hi=(h(key)+i*h1(key)) ％ m，0 ≤ i ≤ m-1 

基本思想是： 
探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+h1(d)], T[d + 2*h1(d)]，…，等。

该方法使用了两个散列函数 h(key) 和 h1(key)，故也称为双散列函数探查法。

定义 h1(key) 的方法较多，但无论采用什么方法定义，都必须使 h1(key) 的值和 m 互素，才能使发生冲突的同义词地址均匀地分布在整个表中，否则可能造成同义词地址的循环计算。

该方法是开放定址法中最好的方法之一。